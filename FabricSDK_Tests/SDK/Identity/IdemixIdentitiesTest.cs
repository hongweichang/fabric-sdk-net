using System;
using System.IO;
using System.Linq;
using Google.Protobuf;
using Hyperledger.Fabric.Protos.Common;
using Hyperledger.Fabric.Protos.Idemix;
using Hyperledger.Fabric.Protos.Msp;
using Hyperledger.Fabric.Protos.Msp.MspConfig;
using Hyperledger.Fabric.SDK.AMCL.FP256BN;
using Hyperledger.Fabric.SDK.Idemix;
using Hyperledger.Fabric.SDK.Identity;
using Hyperledger.Fabric.SDK.Security;
using Hyperledger.Fabric.Tests.Helper;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;
using CryptoException = Hyperledger.Fabric.SDK.Exceptions.CryptoException;
using ECP = Hyperledger.Fabric.SDK.AMCL.FP256BN.ECP;

// ReSharper disable ObjectCreationAsStatement

namespace Hyperledger.Fabric.Tests.SDK.Identity
{
    [TestClass]
    [TestCategory("SDK")]
    public class IdemixIdentitiesTest
    {
        // Test resources with crypto material generated by the idemixgen tool (in go)
        private static readonly string TEST_PATH = "fixture/IdemixIdentitiesTest";
        private static readonly string USER_PATH = "user";
        private static readonly string VERIFIER_PATH = "msp";
        private static readonly string MSP1Broken = "MSP1Broken";
        private static readonly string MSP1OU1 = "MSP1OU1";
        private static readonly string OU1 = "OU1";
        private static readonly string OU2 = "OU2";
        private static readonly string MSP1OU1Admin = "MSP1OU1Admin";
        private static readonly string MSP1OU2 = "MSP1OU2";
        private static readonly string MSP1Verifier = "MSP1Verifier";
        private static readonly string MSP2OU1 = "MSP2OU1";
        private static readonly string SIGNER_CONFIG = "SignerConfig";
        private static readonly string REVOCATION_PUBLIC_KEY = "RevocationPublicKey";
        private static readonly string IPK_CONFIG = "IssuerPublicKey";


        private static IdemixCredential cred;
        private static CredentialRevocationInformation cri;
        private static IdemixIssuerPublicKey ipk;
        private static KeyPair revocationPk;
        private static BIG sk;
        private static IdemixPseudonym nym;
        private static ECP nymPublic;
        private static IdemixSignature proof;
        private static IdemixSigningIdentity signingIdentity;

        private static readonly byte[] message = {1, 2, 3, 4};
        private static readonly byte[] sigTest = {1, 2, 3, 4};

        // Setup using a happy path
        [ClassInitialize]
        public static void Setup(TestContext context)
        {
            // Parse crypto material from files
            IdemixMSPSignerConfig signerConfig = null;
            try
            {
                signerConfig = ReadIdemixMSPConfig(Path.Combine(TEST_PATH, MSP1OU1, USER_PATH).Locate(), SIGNER_CONFIG);
            }
            catch (System.Exception e)
            {
                Assert.Fail("Unexpected exception while reading signerconfig: " + e.Message);
            }

            Assert.IsNotNull(signerConfig);

            try
            {
                revocationPk = ReadIdemixRevocationPublicKey(Path.Combine(TEST_PATH, MSP1OU1, VERIFIER_PATH).Locate(), REVOCATION_PUBLIC_KEY);
            }
            catch (System.Exception e)
            {
                Assert.Fail("Unexpected exception while reading revocation public key: " + e.Message);
            }

            Assert.IsNotNull(revocationPk);

            IssuerPublicKey ipkProto = null;
            try
            {
                ipkProto = ReadIdemixIssuerPublicKey(Path.Combine(TEST_PATH, MSP1OU1, VERIFIER_PATH).Locate(), IPK_CONFIG);
            }
            catch (IOException e1)
            {
                Assert.Fail("Unexpected exception while reading revocation public key" + e1.Message);
            }

            ipk = new IdemixIssuerPublicKey(ipkProto);
            Assert.IsTrue(ipk.Check());

            sk = BIG.FromBytes(signerConfig.Sk.ToByteArray());

            Credential credProto = null;
            try
            {
                credProto = Credential.Parser.ParseFrom(signerConfig.Cred);
            }
            catch (InvalidProtocolBufferException)
            {
                Assert.Fail("Could not parse a credential");
            }

            Assert.IsNotNull(credProto);

            cred = new IdemixCredential(credProto);

            try
            {
                cri = CredentialRevocationInformation.Parser.ParseFrom(signerConfig.CredentialRevocationInformation);
            }
            catch (InvalidProtocolBufferException e)
            {
                Assert.Fail("failed to extract cri from signer config: " + e.Message);
            }

            Assert.IsNotNull(cri);

            try
            {
                signingIdentity = new IdemixSigningIdentity(ipk, revocationPk, MSP1OU1, sk, cred, cri, OU1, IdemixRoles.MEMBER);
            }
            catch (System.Exception e) when (e is CryptoException || e is ArgumentException)
            {
                Assert.Fail("Could not create Idemix Signing Identity" + e.Message);
            }

            Assert.IsNotNull(signingIdentity);

            nym = signingIdentity.Pseudonym;

            nymPublic = nym.Nym;

            proof = signingIdentity.Proof;
        }


        // Test creating a signing identity with MSP1Verifier (should fail)
        [TestMethod]
        [ExpectedException(typeof(DirectoryNotFoundException))]
        public void TestIdemixSigningIdentityVerifier()
        {
            try
            {
                CreateIdemixSigningIdentity(MSP1Verifier);
            }
            catch (System.Exception e) when (e is CryptoException || e is ArgumentException)
            {
                /* If exception throw test fails */
            }
        }

        // Test creating a signing identity with MSP1Broken (should fail)
        [TestMethod]
        public void TestIdemixSigningIdentityBroken()
        {
            try
            {
                CreateIdemixSigningIdentity(MSP1Broken);
                Assert.Fail("Expecting IOException or InvalidProtocolBufferException");
            }
            catch (System.Exception)
            {
                //Ignore
            }
        }


        // Test creating a signer config
        [TestMethod]
        public void TestIdemixMSPSignerConfigSuccess()
        {
            IdemixMSPSignerConfig signerConfig = null;
            try
            {
                signerConfig = ReadIdemixMSPConfig(Path.Combine(TEST_PATH, MSP1OU1, USER_PATH).Locate(), SIGNER_CONFIG);
            }
            catch (InvalidProtocolBufferException e)
            {
                Assert.Fail("Unexpected IPBException" + e.Message);
            }
            catch (IOException e)
            {
                Assert.Fail("Unexpected IOException" + e.Message);
            }

            Assert.IsNotNull(signerConfig);
        }

        // Test creating a signing identity from null input
        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullPk()
        {
            new IdemixSigningIdentity(null, revocationPk, MSP1OU1, sk, cred, cri, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullRevPk()
        {
            new IdemixSigningIdentity(ipk, null, MSP1OU1, sk, cred, cri, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullMsp()
        {
            new IdemixSigningIdentity(ipk, revocationPk, null, sk, cred, cri, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputEmptymsp()
        {
            new IdemixSigningIdentity(ipk, revocationPk, "", sk, cred, cri, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullSk()
        {
            new IdemixSigningIdentity(ipk, revocationPk, MSP1OU1, null, cred, cri, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullCri()
        {
            new IdemixSigningIdentity(ipk, revocationPk, MSP1OU1, sk, cred, null, OU1, IdemixRoles.MEMBER);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixSigningIdentityInputNullCred()
        {
            new IdemixSigningIdentity(ipk, revocationPk, MSP1OU1, sk, null, cri, OU1, IdemixRoles.MEMBER);
        }

        // Test Signing and Verification with Signing Identity
        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestSigningNullMsg()
        {
            TestSigning(signingIdentity, message, null, true);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestSigningNullSig()
        {
            TestSigning(signingIdentity, null, sigTest, true);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestSigningNullMsgSig()
        {
            TestSigning(signingIdentity, null, null, true);
        }

        [TestMethod]
        public void TestSigningSuccess()
        {
            Assert.IsTrue(TestSigning(signingIdentity, message, null, false));
        }


        [TestMethod]
        public void TestSerializingAndDeserializingIdentity()
        {
            SerializedIdentity proto = signingIdentity.CreateSerializedIdentity();
            Assert.IsNotNull(proto);

            SerializedIdemixIdentity idemixProto = null;
            try
            {
                idemixProto = SerializedIdemixIdentity.Parser.ParseFrom(proto.IdBytes);
            }
            catch (InvalidProtocolBufferException e)
            {
                Assert.Fail("Could not parse Idemix Serialized Identity" + e.Message);
            }

            if (idemixProto != null)
            {
                new ECP(BIG.FromBytes(idemixProto.NymX.ToByteArray()), BIG.FromBytes(idemixProto.NymY.ToByteArray()));
                idemixProto.Ou.ToByteArray();
                idemixProto.Role.ToByteArray();
                try
                {
                    new IdemixSignature(Signature.Parser.ParseFrom(idemixProto.Proof.ToByteArray()));
                }
                catch (InvalidProtocolBufferException e)
                {
                    Assert.Fail("Cannot deserialize proof" + e.Message);
                }
            }

            try
            {
                new IdemixIdentity(proto);
            }
            catch (System.Exception e) when (e is CryptoException || e is ArgumentException)
            {
                Assert.Fail("Cannot create Idemix Identity from Proto" + e.Message);
            }
        }

        // Test creating IdemixIdentity

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNull()
        {
            new IdemixIdentity(null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNullMsp()
        {
            new IdemixIdentity(null, ipk, nymPublic, OU1, IdemixRoles.MEMBER, proof);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNullNym()
        {
            new IdemixIdentity(MSP1OU1, ipk, null, OU1, IdemixRoles.MEMBER, proof);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNullOu()
        {
            new IdemixIdentity(MSP1OU1, ipk, nymPublic, null, IdemixRoles.MEMBER, proof);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNullProof()
        {
            new IdemixIdentity(MSP1OU1, ipk, nymPublic, OU1, IdemixRoles.MEMBER, null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void TestIdemixIdentityInputNullIpk()
        {
            new IdemixIdentity(MSP1OU1, null, nymPublic, OU1, IdemixRoles.MEMBER, proof);
        }

        [TestMethod]
        public void TestIdemixIdentity()
        {
            try
            {
                new IdemixIdentity(MSP1OU1, ipk, nymPublic, OU1, IdemixRoles.MEMBER, proof);
            }
            catch (ArgumentException e)
            {
                Assert.Fail("Unexpected Invalid Argument exception" + e.Message);
            }
        }


// Test creating different signing identities
        [TestMethod]
        public void TestSigningIdentityMSP1OU1Admin()
        {
            Assert.IsTrue(TestCreatingSigningIdentityAndSign(MSP1OU1Admin));
        }

        [TestMethod]
        public void TestSigningIdentityMSP1OU2()
        {
            Assert.IsTrue(TestCreatingSigningIdentityAndSign(MSP1OU2));
        }

        [TestMethod]
        public void TestSigningIdentityMSP2OU1()
        {
            Assert.IsTrue(TestCreatingSigningIdentityAndSign(MSP2OU1));
        }

// Helper functions

/**
 * Helper function to create a Signing Identity and sign with it
 *
 * @param mspId
 * @return
 */
        public bool TestCreatingSigningIdentityAndSign(string mspId)
        {
            bool b = false;

            IdemixSigningIdentity signingIdentityTest = null;
            try
            {
                signingIdentityTest = CreateIdemixSigningIdentity(mspId);
            }
            catch (System.Exception e)
            {
                Assert.Fail("Unexpected exception: " + e.Message);
            }

            Assert.IsNotNull(signingIdentityTest);

            // Test signing using this identity
            try
            {
                b = TestSigning(signingIdentityTest, message, null, false);
            }
            catch (System.Exception e) when (e is CryptoException || e is ArgumentException)
            {
                Assert.Fail("Unexpected exception: " + e.Message);
            }

            return b;
        }


        /**
         * Helper function for testing signing
         *
         * @param signIdentity
         * @return
         * @throws InvalidArgumentException
         */
        public bool TestSigning(IdemixSigningIdentity signIdentity, byte[] msg, byte[] sigInput, bool useInputSig)
        {
            byte[] sig = signIdentity.Sign(msg);
            byte[] otherMsg = {1, 1, 1, 1};

            if (useInputSig)
            {
                Assert.IsFalse(signIdentity.VerifySignature(otherMsg, sigInput));
                return signIdentity.VerifySignature(msg, sigInput);
            }

            Assert.IsFalse(signIdentity.VerifySignature(otherMsg, sig));
            return signIdentity.VerifySignature(msg, sig);
        }

        /**
         * Helper function to create IdemixSigningIdentity from a file generated by idemixgen go tool
         *
         * @param mspId
         * @return IdemixSigningIdentity object
         * @throws IOException
         * @throws InvalidProtocolBufferException
         */
        private IdemixSigningIdentity CreateIdemixSigningIdentity(string mspId)
        {
            IdemixMSPSignerConfig signerConfig;
            signerConfig = ReadIdemixMSPConfig(Path.Combine(TEST_PATH, mspId, USER_PATH).Locate(), SIGNER_CONFIG);
            Assert.IsNotNull(signerConfig);

            IssuerPublicKey ipkProto = ReadIdemixIssuerPublicKey(Path.Combine(TEST_PATH, mspId, VERIFIER_PATH).Locate(), IPK_CONFIG);
            IdemixIssuerPublicKey ipkt = new IdemixIssuerPublicKey(ipkProto);
            Assert.IsTrue(ipkt.Check());

            KeyPair revPk = ReadIdemixRevocationPublicKey(Path.Combine(TEST_PATH, mspId, VERIFIER_PATH).Locate(), REVOCATION_PUBLIC_KEY);

            BIG skt = BIG.FromBytes(signerConfig.Sk.ToByteArray());

            Credential credProto = Credential.Parser.ParseFrom(signerConfig.Cred);

            Assert.IsNotNull(credProto);

            IdemixCredential credt = new IdemixCredential(credProto);

            CredentialRevocationInformation crit = CredentialRevocationInformation.Parser.ParseFrom(signerConfig.CredentialRevocationInformation);

            return new IdemixSigningIdentity(ipkt, revPk, mspId, skt, credt, crit, signerConfig.OrganizationalUnitIdentifier, (IdemixRoles) signerConfig.Role);
        }

        /**
         * Helper function: parse Idemix MSP Signer config (is part of the MSPConfig proto) from path
         *
         * @param configPath
         * @param id
         * @return IdemixMSPSignerConfig proto
         */
        public static IdemixMSPSignerConfig ReadIdemixMSPConfig(string configPath, string id)
        {
            string path = Path.Combine(configPath, id);
            byte[] data = File.ReadAllBytes(path);
            IdemixMSPSignerConfig signerConfig = IdemixMSPSignerConfig.Parser.ParseFrom(data);
            return signerConfig;
        }

        /**
         * Parse Idemix issuer public key from the config file
         *
         * @param configPath
         * @param id
         * @return Idemix IssuerPublicKey proto
         */
        public static IssuerPublicKey ReadIdemixIssuerPublicKey(string configPath, string id)
        {
            string path = Path.Combine(configPath, id);
            byte[] data = File.ReadAllBytes(path);
            return IssuerPublicKey.Parser.ParseFrom(data);
        }

        /**
         * Parse Idemix long-term revocation public key from the config file
         *
         * @param configPath
         * @param id
         * @return the long-term revocation public key
         */
        public static KeyPair ReadIdemixRevocationPublicKey(string configPath, string id)
        {
            string path = Path.Combine(configPath,id);
            byte[] data = KeyPair.PemToDer(File.ReadAllText(path));
            AsymmetricKeyParameter pub = PublicKeyFactory.CreateKey(data);
            return KeyPair.Create(pub, null);
        }

        
        /**
         * Test for IdemixRoles bitmasking
         */
        [TestMethod]
        public void TestIdemixRoles()
        {
            IdemixRoles role = IdemixRoles.ADMIN | IdemixRoles.CLIENT;

            Assert.IsTrue(role.CheckRole(IdemixRoles.ADMIN));
            Assert.IsFalse(role.CheckRole(IdemixRoles.PEER));
            Assert.IsFalse(role.CheckRole(IdemixRoles.MEMBER));
            Assert.IsTrue(role.CheckRole(IdemixRoles.CLIENT));

            Assert.AreEqual(MSPRole.Types.MSPRoleType.Member.ToIdemixRole(), IdemixRoles.MEMBER);
            Assert.AreEqual(IdemixRoles.ADMIN.ToMSPRoleTypes().First(), MSPRole.Types.MSPRoleType.Admin);
        }
    }
}